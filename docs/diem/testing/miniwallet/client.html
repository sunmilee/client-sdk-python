<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>diem.testing.miniwallet.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>diem.testing.miniwallet.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) The Diem Core Contributors
# SPDX-License-Identifier: Apache-2.0

from dataclasses import dataclass, field, replace, asdict
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry
from typing import List, Optional, Any, Dict, Callable
from .app import KycSample, Event
from .app.store import _match
from ... import offchain, jsonrpc
import requests, logging, random, string, json, time, os


@dataclass
class Payment:
    id: str
    account_id: str
    currency: str
    amount: int
    payee: str


@dataclass
class RestClient:
    name: str
    server_url: str
    session: requests.Session = field(default_factory=requests.Session)
    logger: logging.Logger = field(init=False)

    def __post_init__(self) -&gt; None:
        self.logger = logging.getLogger(self.name)

    def with_retry(self, retry: Retry = Retry(total=5, connect=5, backoff_factor=0.01)) -&gt; &#34;RestClient&#34;:
        self.session.mount(self.server_url, HTTPAdapter(max_retries=retry))
        return self

    def create_account(
        self,
        balances: Optional[Dict[str, int]] = None,
        kyc_data: Optional[offchain.KycDataObject] = None,
        reject_additional_kyc_data_request: Optional[bool] = None,
    ) -&gt; &#34;AccountResource&#34;:
        kwargs = {
            &#34;balances&#34;: balances,
            &#34;kyc_data&#34;: asdict(kyc_data) if kyc_data else None,
            &#34;reject_additional_kyc_data_request&#34;: reject_additional_kyc_data_request,
        }
        account = self.create(&#34;/accounts&#34;, **{k: v for k, v in kwargs.items() if v})
        return AccountResource(client=self, id=account[&#34;id&#34;], kyc_data=kyc_data)

    def new_kyc_data(self, name: Optional[str] = None, sample: str = &#34;minimum&#34;) -&gt; offchain.KycDataObject:
        obj = getattr(self.kyc_sample(), sample)
        if not name:
            name = &#34;&#34;.join(random.choices(string.ascii_uppercase + string.digits, k=6))
        return replace(obj, legal_entity_name=name)

    def kyc_sample(self) -&gt; KycSample:
        return offchain.from_dict(self.send(&#34;GET&#34;, &#34;/kyc_sample&#34;).json(), KycSample)

    def create(self, path: str, **kwargs: Any) -&gt; Dict[str, Any]:
        return self.send(&#34;POST&#34;, path, json.dumps(kwargs) if kwargs else None).json()

    def get(self, path: str) -&gt; Dict[str, Any]:
        return self.send(&#34;GET&#34;, path).json()

    def send(self, method: str, path: str, data: Optional[str] = None) -&gt; requests.Response:
        url = &#34;%s/%s&#34; % (self.server_url.rstrip(&#34;/&#34;), path.lstrip(&#34;/&#34;))
        self.logger.debug(&#34;%s %s: %s&#34;, method, path, data)
        headers = {
            &#34;Content-Type&#34;: &#34;application/json&#34;,
            &#34;User-Agent&#34;: jsonrpc.client.USER_AGENT_HTTP_HEADER,
            &#34;X-Test-Case&#34;: os.getenv(&#34;PYTEST_CURRENT_TEST&#34;),
        }
        resp = self.session.request(
            method=method,
            url=url.lower(),
            data=data,
            headers={k: v for k, v in headers.items() if v},
        )
        log_level = logging.DEBUG if resp.status_code &lt; 300 else logging.ERROR
        self.logger.log(log_level, &#34;%s %s: %s - %s&#34;, method, path, data, resp.status_code)
        self.logger.log(log_level, &#34;response body: \n%s&#34;, try_json(resp.text))
        resp.raise_for_status()
        return resp


def try_json(text: str) -&gt; str:
    try:
        obj = json.loads(text)
        if isinstance(obj, dict):
            # pretty print error json stacktrace info
            return &#34;\n&#34;.join([&#34;%s: %s&#34; % (k, v) for k, v in obj.items()])
        return json.dumps(obj, indent=2)
    except Exception:
        return text


@dataclass
class AccountResource:

    client: RestClient
    id: str
    kyc_data: Optional[offchain.KycDataObject] = field(default=None)

    def balance(self, currency: str) -&gt; int:
        &#34;&#34;&#34;Get account balance for the given currency

        Calls `GET /accounts/{account_id}/balances` endpoint and only return balance of the given currency.
        Returns 0 if given currency does not exist in the returned balances.
        &#34;&#34;&#34;

        return self.balances().get(currency, 0)

    def send_payment(self, currency: str, amount: int, payee: str) -&gt; Payment:
        &#34;&#34;&#34;Send amount of currency to payee

        Calls `POST /accounts/{account_id}/payments` endpoint and returns payment details.
        &#34;&#34;&#34;

        p = self.client.create(self._resources(&#34;payment&#34;), payee=payee, currency=currency, amount=amount)
        return Payment(id=p[&#34;id&#34;], account_id=self.id, payee=payee, currency=currency, amount=amount)

    def generate_account_identifier(self) -&gt; str:
        &#34;&#34;&#34;Generate an account identifier

        Calls `POST /accounts/{account_id}/account_identifiers` to generate account identifier.
        &#34;&#34;&#34;

        ret = self.client.create(self._resources(&#34;account_identifier&#34;))
        return ret[&#34;account_identifier&#34;]

    def events(self, start: int = 0) -&gt; List[Event]:
        &#34;&#34;&#34;Get account events

        Calls to `GET /accounts/{account_id}/events` endpoint and returns events list.

        Raises `requests.HTTPError`, if the endpoint is not implemented.
        &#34;&#34;&#34;

        ret = self.client.send(&#34;GET&#34;, self._resources(&#34;event&#34;)).json()
        return [Event(**obj) for obj in ret[start:]]

    def wait_for_balance(self, currency: str, amount: int) -&gt; None:
        &#34;&#34;&#34;Wait for account balance of the given currency meets given `amount`

        Raises TimeoutError and AssertionError if waitted too long time (about 12 seconds,
        120 tries for every 0.1 second).
        &#34;&#34;&#34;

        def fn() -&gt; None:
            assert self.balance(currency) == amount

        self.wait_for(fn)

    def find_event(self, event_type: str, start_index: int = 0, **kwargs: Any) -&gt; Optional[Event]:
        &#34;&#34;&#34;Find a specific event by `type`, `start_index` and `data`

        When matching the event `data`, it assumes `data` is JSON encoded dictionary, and
        returns the event if the `**kwargs` is subset of the dictionary decoded from event `data` field.
        &#34;&#34;&#34;

        events = [e for e in self.events(start_index) if e.type == event_type]
        for e in events:
            if _match(json.loads(e.data), **kwargs):
                return e

    def wait_for_event(self, event_type: str, start_index: int = 0, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Wait for a specific event happened.

        Internally calls to `find_event` to decided whether the event happened.
        See `find_event` for arguments document.
        &#34;&#34;&#34;

        def fn() -&gt; None:
            event = self.find_event(event_type, start_index=start_index, **kwargs)
            assert event, &#34;could not find %s event with %s&#34; % (event_type, (start_index, kwargs))

        self.wait_for(fn)

    def wait_for(self, fn: Callable[[], None], max_tries: int = 120, delay: float = 0.1) -&gt; None:
        &#34;&#34;&#34;Wait for a fucntion call success

        The given `fn` argument should:

            1. Raise `AssertionError` for the case condition not meet and continue to wait.
            2. Return `None` for success (meet condition)
        &#34;&#34;&#34;

        tries = 0
        while True:
            tries += 1
            try:
                return fn()
            except AssertionError as e:
                if tries &gt;= max_tries:
                    raise TimeoutError(&#34;account(%s) events: %s&#34; % (self.id, self.dump_events())) from e
                time.sleep(delay)

    def log_events(self) -&gt; None:
        &#34;&#34;&#34;Log account events as INFO

        Does nothing if get events API is not implemented.
        &#34;&#34;&#34;

        events = self.dump_events()
        if events:
            self.client.logger.info(&#34;account(%s) events: %s&#34;, self.id, events)

    def dump_events(self) -&gt; str:
        &#34;&#34;&#34;Dump account events as JSON encoded string (well formatted, and indent=2)

        Returns empty string if get events API is not implemented.
        &#34;&#34;&#34;

        try:
            return json.dumps(list(map(self.event_asdict, self.events())), indent=2)
        except requests.HTTPError:
            return &#34;&#34;

    def event_asdict(self, event: Event) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Returns `Event` as dictionary object.

        As we use JSON-encoded string field, this function tries to decoding all JSON-encoded
        string as dictionary for pretty print event data in log.
        &#34;&#34;&#34;

        ret = asdict(event)
        try:
            ret[&#34;data&#34;] = json.loads(event.data)
        except json.decoder.JSONDecodeError:
            pass
        return ret

    def info(self, *args: Any, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Log info to `client.logger`&#34;&#34;&#34;

        self.client.logger.info(*args, **kwargs)

    def balances(self) -&gt; Dict[str, int]:
        &#34;&#34;&#34;returns account balances object

        should always prefer to use func `balance(currency) -&gt; int`, which returns zero
        when currency not exist in the response.
        &#34;&#34;&#34;

        return self.client.get(self._resources(&#34;balance&#34;))

    def _resources(self, resource: str) -&gt; str:
        return &#34;/accounts/%s/%ss&#34; % (self.id, resource)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="diem.testing.miniwallet.client.try_json"><code class="name flex">
<span>def <span class="ident">try_json</span></span>(<span>text: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_json(text: str) -&gt; str:
    try:
        obj = json.loads(text)
        if isinstance(obj, dict):
            # pretty print error json stacktrace info
            return &#34;\n&#34;.join([&#34;%s: %s&#34; % (k, v) for k, v in obj.items()])
        return json.dumps(obj, indent=2)
    except Exception:
        return text</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="diem.testing.miniwallet.client.AccountResource"><code class="flex name class">
<span>class <span class="ident">AccountResource</span></span>
<span>(</span><span>client: <a title="diem.testing.miniwallet.client.RestClient" href="#diem.testing.miniwallet.client.RestClient">RestClient</a>, id: str, kyc_data: Optional[<a title="diem.offchain.types.payment_types.KycDataObject" href="../../offchain/types/payment_types.html#diem.offchain.types.payment_types.KycDataObject">KycDataObject</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>AccountResource(client: diem.testing.miniwallet.client.RestClient, id: str, kyc_data: Optional[diem.offchain.types.payment_types.KycDataObject] = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class AccountResource:

    client: RestClient
    id: str
    kyc_data: Optional[offchain.KycDataObject] = field(default=None)

    def balance(self, currency: str) -&gt; int:
        &#34;&#34;&#34;Get account balance for the given currency

        Calls `GET /accounts/{account_id}/balances` endpoint and only return balance of the given currency.
        Returns 0 if given currency does not exist in the returned balances.
        &#34;&#34;&#34;

        return self.balances().get(currency, 0)

    def send_payment(self, currency: str, amount: int, payee: str) -&gt; Payment:
        &#34;&#34;&#34;Send amount of currency to payee

        Calls `POST /accounts/{account_id}/payments` endpoint and returns payment details.
        &#34;&#34;&#34;

        p = self.client.create(self._resources(&#34;payment&#34;), payee=payee, currency=currency, amount=amount)
        return Payment(id=p[&#34;id&#34;], account_id=self.id, payee=payee, currency=currency, amount=amount)

    def generate_account_identifier(self) -&gt; str:
        &#34;&#34;&#34;Generate an account identifier

        Calls `POST /accounts/{account_id}/account_identifiers` to generate account identifier.
        &#34;&#34;&#34;

        ret = self.client.create(self._resources(&#34;account_identifier&#34;))
        return ret[&#34;account_identifier&#34;]

    def events(self, start: int = 0) -&gt; List[Event]:
        &#34;&#34;&#34;Get account events

        Calls to `GET /accounts/{account_id}/events` endpoint and returns events list.

        Raises `requests.HTTPError`, if the endpoint is not implemented.
        &#34;&#34;&#34;

        ret = self.client.send(&#34;GET&#34;, self._resources(&#34;event&#34;)).json()
        return [Event(**obj) for obj in ret[start:]]

    def wait_for_balance(self, currency: str, amount: int) -&gt; None:
        &#34;&#34;&#34;Wait for account balance of the given currency meets given `amount`

        Raises TimeoutError and AssertionError if waitted too long time (about 12 seconds,
        120 tries for every 0.1 second).
        &#34;&#34;&#34;

        def fn() -&gt; None:
            assert self.balance(currency) == amount

        self.wait_for(fn)

    def find_event(self, event_type: str, start_index: int = 0, **kwargs: Any) -&gt; Optional[Event]:
        &#34;&#34;&#34;Find a specific event by `type`, `start_index` and `data`

        When matching the event `data`, it assumes `data` is JSON encoded dictionary, and
        returns the event if the `**kwargs` is subset of the dictionary decoded from event `data` field.
        &#34;&#34;&#34;

        events = [e for e in self.events(start_index) if e.type == event_type]
        for e in events:
            if _match(json.loads(e.data), **kwargs):
                return e

    def wait_for_event(self, event_type: str, start_index: int = 0, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Wait for a specific event happened.

        Internally calls to `find_event` to decided whether the event happened.
        See `find_event` for arguments document.
        &#34;&#34;&#34;

        def fn() -&gt; None:
            event = self.find_event(event_type, start_index=start_index, **kwargs)
            assert event, &#34;could not find %s event with %s&#34; % (event_type, (start_index, kwargs))

        self.wait_for(fn)

    def wait_for(self, fn: Callable[[], None], max_tries: int = 120, delay: float = 0.1) -&gt; None:
        &#34;&#34;&#34;Wait for a fucntion call success

        The given `fn` argument should:

            1. Raise `AssertionError` for the case condition not meet and continue to wait.
            2. Return `None` for success (meet condition)
        &#34;&#34;&#34;

        tries = 0
        while True:
            tries += 1
            try:
                return fn()
            except AssertionError as e:
                if tries &gt;= max_tries:
                    raise TimeoutError(&#34;account(%s) events: %s&#34; % (self.id, self.dump_events())) from e
                time.sleep(delay)

    def log_events(self) -&gt; None:
        &#34;&#34;&#34;Log account events as INFO

        Does nothing if get events API is not implemented.
        &#34;&#34;&#34;

        events = self.dump_events()
        if events:
            self.client.logger.info(&#34;account(%s) events: %s&#34;, self.id, events)

    def dump_events(self) -&gt; str:
        &#34;&#34;&#34;Dump account events as JSON encoded string (well formatted, and indent=2)

        Returns empty string if get events API is not implemented.
        &#34;&#34;&#34;

        try:
            return json.dumps(list(map(self.event_asdict, self.events())), indent=2)
        except requests.HTTPError:
            return &#34;&#34;

    def event_asdict(self, event: Event) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Returns `Event` as dictionary object.

        As we use JSON-encoded string field, this function tries to decoding all JSON-encoded
        string as dictionary for pretty print event data in log.
        &#34;&#34;&#34;

        ret = asdict(event)
        try:
            ret[&#34;data&#34;] = json.loads(event.data)
        except json.decoder.JSONDecodeError:
            pass
        return ret

    def info(self, *args: Any, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;Log info to `client.logger`&#34;&#34;&#34;

        self.client.logger.info(*args, **kwargs)

    def balances(self) -&gt; Dict[str, int]:
        &#34;&#34;&#34;returns account balances object

        should always prefer to use func `balance(currency) -&gt; int`, which returns zero
        when currency not exist in the response.
        &#34;&#34;&#34;

        return self.client.get(self._resources(&#34;balance&#34;))

    def _resources(self, resource: str) -&gt; str:
        return &#34;/accounts/%s/%ss&#34; % (self.id, resource)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="diem.testing.miniwallet.client.AccountResource.client"><code class="name">var <span class="ident">client</span> : <a title="diem.testing.miniwallet.client.RestClient" href="#diem.testing.miniwallet.client.RestClient">RestClient</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.kyc_data"><code class="name">var <span class="ident">kyc_data</span> : Optional[<a title="diem.offchain.types.payment_types.KycDataObject" href="../../offchain/types/payment_types.html#diem.offchain.types.payment_types.KycDataObject">KycDataObject</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="diem.testing.miniwallet.client.AccountResource.balance"><code class="name flex">
<span>def <span class="ident">balance</span></span>(<span>self, currency: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get account balance for the given currency</p>
<p>Calls <code>GET /accounts/{account_id}/balances</code> endpoint and only return balance of the given currency.
Returns 0 if given currency does not exist in the returned balances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def balance(self, currency: str) -&gt; int:
    &#34;&#34;&#34;Get account balance for the given currency

    Calls `GET /accounts/{account_id}/balances` endpoint and only return balance of the given currency.
    Returns 0 if given currency does not exist in the returned balances.
    &#34;&#34;&#34;

    return self.balances().get(currency, 0)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.balances"><code class="name flex">
<span>def <span class="ident">balances</span></span>(<span>self) ‑> Dict[str, int]</span>
</code></dt>
<dd>
<div class="desc"><p>returns account balances object</p>
<p>should always prefer to use func <code>balance(currency) -&gt; int</code>, which returns zero
when currency not exist in the response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def balances(self) -&gt; Dict[str, int]:
    &#34;&#34;&#34;returns account balances object

    should always prefer to use func `balance(currency) -&gt; int`, which returns zero
    when currency not exist in the response.
    &#34;&#34;&#34;

    return self.client.get(self._resources(&#34;balance&#34;))</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.dump_events"><code class="name flex">
<span>def <span class="ident">dump_events</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Dump account events as JSON encoded string (well formatted, and indent=2)</p>
<p>Returns empty string if get events API is not implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_events(self) -&gt; str:
    &#34;&#34;&#34;Dump account events as JSON encoded string (well formatted, and indent=2)

    Returns empty string if get events API is not implemented.
    &#34;&#34;&#34;

    try:
        return json.dumps(list(map(self.event_asdict, self.events())), indent=2)
    except requests.HTTPError:
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.event_asdict"><code class="name flex">
<span>def <span class="ident">event_asdict</span></span>(<span>self, event: <a title="diem.testing.miniwallet.app.models.Event" href="app/models.html#diem.testing.miniwallet.app.models.Event">Event</a>) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>Event</code> as dictionary object.</p>
<p>As we use JSON-encoded string field, this function tries to decoding all JSON-encoded
string as dictionary for pretty print event data in log.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_asdict(self, event: Event) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Returns `Event` as dictionary object.

    As we use JSON-encoded string field, this function tries to decoding all JSON-encoded
    string as dictionary for pretty print event data in log.
    &#34;&#34;&#34;

    ret = asdict(event)
    try:
        ret[&#34;data&#34;] = json.loads(event.data)
    except json.decoder.JSONDecodeError:
        pass
    return ret</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.events"><code class="name flex">
<span>def <span class="ident">events</span></span>(<span>self, start: int = 0) ‑> List[<a title="diem.testing.miniwallet.app.models.Event" href="app/models.html#diem.testing.miniwallet.app.models.Event">Event</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get account events</p>
<p>Calls to <code>GET /accounts/{account_id}/events</code> endpoint and returns events list.</p>
<p>Raises <code>requests.HTTPError</code>, if the endpoint is not implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def events(self, start: int = 0) -&gt; List[Event]:
    &#34;&#34;&#34;Get account events

    Calls to `GET /accounts/{account_id}/events` endpoint and returns events list.

    Raises `requests.HTTPError`, if the endpoint is not implemented.
    &#34;&#34;&#34;

    ret = self.client.send(&#34;GET&#34;, self._resources(&#34;event&#34;)).json()
    return [Event(**obj) for obj in ret[start:]]</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.find_event"><code class="name flex">
<span>def <span class="ident">find_event</span></span>(<span>self, event_type: str, start_index: int = 0, **kwargs: Any) ‑> Optional[<a title="diem.testing.miniwallet.app.models.Event" href="app/models.html#diem.testing.miniwallet.app.models.Event">Event</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Find a specific event by <code>type</code>, <code>start_index</code> and <code>data</code></p>
<p>When matching the event <code>data</code>, it assumes <code>data</code> is JSON encoded dictionary, and
returns the event if the <code>**kwargs</code> is subset of the dictionary decoded from event <code>data</code> field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_event(self, event_type: str, start_index: int = 0, **kwargs: Any) -&gt; Optional[Event]:
    &#34;&#34;&#34;Find a specific event by `type`, `start_index` and `data`

    When matching the event `data`, it assumes `data` is JSON encoded dictionary, and
    returns the event if the `**kwargs` is subset of the dictionary decoded from event `data` field.
    &#34;&#34;&#34;

    events = [e for e in self.events(start_index) if e.type == event_type]
    for e in events:
        if _match(json.loads(e.data), **kwargs):
            return e</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.generate_account_identifier"><code class="name flex">
<span>def <span class="ident">generate_account_identifier</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an account identifier</p>
<p>Calls <code>POST /accounts/{account_id}/account_identifiers</code> to generate account identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_account_identifier(self) -&gt; str:
    &#34;&#34;&#34;Generate an account identifier

    Calls `POST /accounts/{account_id}/account_identifiers` to generate account identifier.
    &#34;&#34;&#34;

    ret = self.client.create(self._resources(&#34;account_identifier&#34;))
    return ret[&#34;account_identifier&#34;]</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Log info to <code>client.logger</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, *args: Any, **kwargs: Any) -&gt; None:
    &#34;&#34;&#34;Log info to `client.logger`&#34;&#34;&#34;

    self.client.logger.info(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.log_events"><code class="name flex">
<span>def <span class="ident">log_events</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Log account events as INFO</p>
<p>Does nothing if get events API is not implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_events(self) -&gt; None:
    &#34;&#34;&#34;Log account events as INFO

    Does nothing if get events API is not implemented.
    &#34;&#34;&#34;

    events = self.dump_events()
    if events:
        self.client.logger.info(&#34;account(%s) events: %s&#34;, self.id, events)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.send_payment"><code class="name flex">
<span>def <span class="ident">send_payment</span></span>(<span>self, currency: str, amount: int, payee: str) ‑> <a title="diem.testing.miniwallet.client.Payment" href="#diem.testing.miniwallet.client.Payment">Payment</a></span>
</code></dt>
<dd>
<div class="desc"><p>Send amount of currency to payee</p>
<p>Calls <code>POST /accounts/{account_id}/payments</code> endpoint and returns payment details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_payment(self, currency: str, amount: int, payee: str) -&gt; Payment:
    &#34;&#34;&#34;Send amount of currency to payee

    Calls `POST /accounts/{account_id}/payments` endpoint and returns payment details.
    &#34;&#34;&#34;

    p = self.client.create(self._resources(&#34;payment&#34;), payee=payee, currency=currency, amount=amount)
    return Payment(id=p[&#34;id&#34;], account_id=self.id, payee=payee, currency=currency, amount=amount)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.wait_for"><code class="name flex">
<span>def <span class="ident">wait_for</span></span>(<span>self, fn: Callable[[], NoneType], max_tries: int = 120, delay: float = 0.1) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for a fucntion call success</p>
<p>The given <code>fn</code> argument should:</p>
<pre><code>1. Raise &lt;code&gt;AssertionError&lt;/code&gt; for the case condition not meet and continue to wait.
2. Return &lt;code&gt;None&lt;/code&gt; for success (meet condition)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for(self, fn: Callable[[], None], max_tries: int = 120, delay: float = 0.1) -&gt; None:
    &#34;&#34;&#34;Wait for a fucntion call success

    The given `fn` argument should:

        1. Raise `AssertionError` for the case condition not meet and continue to wait.
        2. Return `None` for success (meet condition)
    &#34;&#34;&#34;

    tries = 0
    while True:
        tries += 1
        try:
            return fn()
        except AssertionError as e:
            if tries &gt;= max_tries:
                raise TimeoutError(&#34;account(%s) events: %s&#34; % (self.id, self.dump_events())) from e
            time.sleep(delay)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.wait_for_balance"><code class="name flex">
<span>def <span class="ident">wait_for_balance</span></span>(<span>self, currency: str, amount: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for account balance of the given currency meets given <code>amount</code></p>
<p>Raises TimeoutError and AssertionError if waitted too long time (about 12 seconds,
120 tries for every 0.1 second).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_balance(self, currency: str, amount: int) -&gt; None:
    &#34;&#34;&#34;Wait for account balance of the given currency meets given `amount`

    Raises TimeoutError and AssertionError if waitted too long time (about 12 seconds,
    120 tries for every 0.1 second).
    &#34;&#34;&#34;

    def fn() -&gt; None:
        assert self.balance(currency) == amount

    self.wait_for(fn)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.AccountResource.wait_for_event"><code class="name flex">
<span>def <span class="ident">wait_for_event</span></span>(<span>self, event_type: str, start_index: int = 0, **kwargs: Any) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for a specific event happened.</p>
<p>Internally calls to <code>find_event</code> to decided whether the event happened.
See <code>find_event</code> for arguments document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_event(self, event_type: str, start_index: int = 0, **kwargs: Any) -&gt; None:
    &#34;&#34;&#34;Wait for a specific event happened.

    Internally calls to `find_event` to decided whether the event happened.
    See `find_event` for arguments document.
    &#34;&#34;&#34;

    def fn() -&gt; None:
        event = self.find_event(event_type, start_index=start_index, **kwargs)
        assert event, &#34;could not find %s event with %s&#34; % (event_type, (start_index, kwargs))

    self.wait_for(fn)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="diem.testing.miniwallet.client.Payment"><code class="flex name class">
<span>class <span class="ident">Payment</span></span>
<span>(</span><span>id: str, account_id: str, currency: str, amount: int, payee: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Payment(id: str, account_id: str, currency: str, amount: int, payee: str)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Payment:
    id: str
    account_id: str
    currency: str
    amount: int
    payee: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="diem.testing.miniwallet.client.Payment.account_id"><code class="name">var <span class="ident">account_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.Payment.amount"><code class="name">var <span class="ident">amount</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.Payment.currency"><code class="name">var <span class="ident">currency</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.Payment.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.Payment.payee"><code class="name">var <span class="ident">payee</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient"><code class="flex name class">
<span>class <span class="ident">RestClient</span></span>
<span>(</span><span>name: str, server_url: str, session: requests.sessions.Session = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>RestClient(name: str, server_url: str, session: requests.sessions.Session = <factory>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class RestClient:
    name: str
    server_url: str
    session: requests.Session = field(default_factory=requests.Session)
    logger: logging.Logger = field(init=False)

    def __post_init__(self) -&gt; None:
        self.logger = logging.getLogger(self.name)

    def with_retry(self, retry: Retry = Retry(total=5, connect=5, backoff_factor=0.01)) -&gt; &#34;RestClient&#34;:
        self.session.mount(self.server_url, HTTPAdapter(max_retries=retry))
        return self

    def create_account(
        self,
        balances: Optional[Dict[str, int]] = None,
        kyc_data: Optional[offchain.KycDataObject] = None,
        reject_additional_kyc_data_request: Optional[bool] = None,
    ) -&gt; &#34;AccountResource&#34;:
        kwargs = {
            &#34;balances&#34;: balances,
            &#34;kyc_data&#34;: asdict(kyc_data) if kyc_data else None,
            &#34;reject_additional_kyc_data_request&#34;: reject_additional_kyc_data_request,
        }
        account = self.create(&#34;/accounts&#34;, **{k: v for k, v in kwargs.items() if v})
        return AccountResource(client=self, id=account[&#34;id&#34;], kyc_data=kyc_data)

    def new_kyc_data(self, name: Optional[str] = None, sample: str = &#34;minimum&#34;) -&gt; offchain.KycDataObject:
        obj = getattr(self.kyc_sample(), sample)
        if not name:
            name = &#34;&#34;.join(random.choices(string.ascii_uppercase + string.digits, k=6))
        return replace(obj, legal_entity_name=name)

    def kyc_sample(self) -&gt; KycSample:
        return offchain.from_dict(self.send(&#34;GET&#34;, &#34;/kyc_sample&#34;).json(), KycSample)

    def create(self, path: str, **kwargs: Any) -&gt; Dict[str, Any]:
        return self.send(&#34;POST&#34;, path, json.dumps(kwargs) if kwargs else None).json()

    def get(self, path: str) -&gt; Dict[str, Any]:
        return self.send(&#34;GET&#34;, path).json()

    def send(self, method: str, path: str, data: Optional[str] = None) -&gt; requests.Response:
        url = &#34;%s/%s&#34; % (self.server_url.rstrip(&#34;/&#34;), path.lstrip(&#34;/&#34;))
        self.logger.debug(&#34;%s %s: %s&#34;, method, path, data)
        headers = {
            &#34;Content-Type&#34;: &#34;application/json&#34;,
            &#34;User-Agent&#34;: jsonrpc.client.USER_AGENT_HTTP_HEADER,
            &#34;X-Test-Case&#34;: os.getenv(&#34;PYTEST_CURRENT_TEST&#34;),
        }
        resp = self.session.request(
            method=method,
            url=url.lower(),
            data=data,
            headers={k: v for k, v in headers.items() if v},
        )
        log_level = logging.DEBUG if resp.status_code &lt; 300 else logging.ERROR
        self.logger.log(log_level, &#34;%s %s: %s - %s&#34;, method, path, data, resp.status_code)
        self.logger.log(log_level, &#34;response body: \n%s&#34;, try_json(resp.text))
        resp.raise_for_status()
        return resp</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="diem.testing.miniwallet.client.RestClient.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.server_url"><code class="name">var <span class="ident">server_url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.session"><code class="name">var <span class="ident">session</span> : requests.sessions.Session</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="diem.testing.miniwallet.client.RestClient.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, path: str, **kwargs: Any) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, path: str, **kwargs: Any) -&gt; Dict[str, Any]:
    return self.send(&#34;POST&#34;, path, json.dumps(kwargs) if kwargs else None).json()</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.create_account"><code class="name flex">
<span>def <span class="ident">create_account</span></span>(<span>self, balances: Optional[Dict[str, int]] = None, kyc_data: Optional[<a title="diem.offchain.types.payment_types.KycDataObject" href="../../offchain/types/payment_types.html#diem.offchain.types.payment_types.KycDataObject">KycDataObject</a>] = None, reject_additional_kyc_data_request: Optional[bool] = None) ‑> <a title="diem.testing.miniwallet.client.AccountResource" href="#diem.testing.miniwallet.client.AccountResource">AccountResource</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_account(
    self,
    balances: Optional[Dict[str, int]] = None,
    kyc_data: Optional[offchain.KycDataObject] = None,
    reject_additional_kyc_data_request: Optional[bool] = None,
) -&gt; &#34;AccountResource&#34;:
    kwargs = {
        &#34;balances&#34;: balances,
        &#34;kyc_data&#34;: asdict(kyc_data) if kyc_data else None,
        &#34;reject_additional_kyc_data_request&#34;: reject_additional_kyc_data_request,
    }
    account = self.create(&#34;/accounts&#34;, **{k: v for k, v in kwargs.items() if v})
    return AccountResource(client=self, id=account[&#34;id&#34;], kyc_data=kyc_data)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, path: str) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, path: str) -&gt; Dict[str, Any]:
    return self.send(&#34;GET&#34;, path).json()</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.kyc_sample"><code class="name flex">
<span>def <span class="ident">kyc_sample</span></span>(<span>self) ‑> <a title="diem.testing.miniwallet.app.models.KycSample" href="app/models.html#diem.testing.miniwallet.app.models.KycSample">KycSample</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kyc_sample(self) -&gt; KycSample:
    return offchain.from_dict(self.send(&#34;GET&#34;, &#34;/kyc_sample&#34;).json(), KycSample)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.new_kyc_data"><code class="name flex">
<span>def <span class="ident">new_kyc_data</span></span>(<span>self, name: Optional[str] = None, sample: str = 'minimum') ‑> <a title="diem.offchain.types.payment_types.KycDataObject" href="../../offchain/types/payment_types.html#diem.offchain.types.payment_types.KycDataObject">KycDataObject</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_kyc_data(self, name: Optional[str] = None, sample: str = &#34;minimum&#34;) -&gt; offchain.KycDataObject:
    obj = getattr(self.kyc_sample(), sample)
    if not name:
        name = &#34;&#34;.join(random.choices(string.ascii_uppercase + string.digits, k=6))
    return replace(obj, legal_entity_name=name)</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, method: str, path: str, data: Optional[str] = None) ‑> requests.models.Response</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, method: str, path: str, data: Optional[str] = None) -&gt; requests.Response:
    url = &#34;%s/%s&#34; % (self.server_url.rstrip(&#34;/&#34;), path.lstrip(&#34;/&#34;))
    self.logger.debug(&#34;%s %s: %s&#34;, method, path, data)
    headers = {
        &#34;Content-Type&#34;: &#34;application/json&#34;,
        &#34;User-Agent&#34;: jsonrpc.client.USER_AGENT_HTTP_HEADER,
        &#34;X-Test-Case&#34;: os.getenv(&#34;PYTEST_CURRENT_TEST&#34;),
    }
    resp = self.session.request(
        method=method,
        url=url.lower(),
        data=data,
        headers={k: v for k, v in headers.items() if v},
    )
    log_level = logging.DEBUG if resp.status_code &lt; 300 else logging.ERROR
    self.logger.log(log_level, &#34;%s %s: %s - %s&#34;, method, path, data, resp.status_code)
    self.logger.log(log_level, &#34;response body: \n%s&#34;, try_json(resp.text))
    resp.raise_for_status()
    return resp</code></pre>
</details>
</dd>
<dt id="diem.testing.miniwallet.client.RestClient.with_retry"><code class="name flex">
<span>def <span class="ident">with_retry</span></span>(<span>self, retry: urllib3.util.retry.Retry = Retry(total=5, connect=5, read=None, redirect=None, status=None)) ‑> <a title="diem.testing.miniwallet.client.RestClient" href="#diem.testing.miniwallet.client.RestClient">RestClient</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_retry(self, retry: Retry = Retry(total=5, connect=5, backoff_factor=0.01)) -&gt; &#34;RestClient&#34;:
    self.session.mount(self.server_url, HTTPAdapter(max_retries=retry))
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="diem.testing.miniwallet" href="index.html">diem.testing.miniwallet</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="diem.testing.miniwallet.client.try_json" href="#diem.testing.miniwallet.client.try_json">try_json</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="diem.testing.miniwallet.client.AccountResource" href="#diem.testing.miniwallet.client.AccountResource">AccountResource</a></code></h4>
<ul class="">
<li><code><a title="diem.testing.miniwallet.client.AccountResource.balance" href="#diem.testing.miniwallet.client.AccountResource.balance">balance</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.balances" href="#diem.testing.miniwallet.client.AccountResource.balances">balances</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.client" href="#diem.testing.miniwallet.client.AccountResource.client">client</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.dump_events" href="#diem.testing.miniwallet.client.AccountResource.dump_events">dump_events</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.event_asdict" href="#diem.testing.miniwallet.client.AccountResource.event_asdict">event_asdict</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.events" href="#diem.testing.miniwallet.client.AccountResource.events">events</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.find_event" href="#diem.testing.miniwallet.client.AccountResource.find_event">find_event</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.generate_account_identifier" href="#diem.testing.miniwallet.client.AccountResource.generate_account_identifier">generate_account_identifier</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.id" href="#diem.testing.miniwallet.client.AccountResource.id">id</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.info" href="#diem.testing.miniwallet.client.AccountResource.info">info</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.kyc_data" href="#diem.testing.miniwallet.client.AccountResource.kyc_data">kyc_data</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.log_events" href="#diem.testing.miniwallet.client.AccountResource.log_events">log_events</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.send_payment" href="#diem.testing.miniwallet.client.AccountResource.send_payment">send_payment</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.wait_for" href="#diem.testing.miniwallet.client.AccountResource.wait_for">wait_for</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.wait_for_balance" href="#diem.testing.miniwallet.client.AccountResource.wait_for_balance">wait_for_balance</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.AccountResource.wait_for_event" href="#diem.testing.miniwallet.client.AccountResource.wait_for_event">wait_for_event</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="diem.testing.miniwallet.client.Payment" href="#diem.testing.miniwallet.client.Payment">Payment</a></code></h4>
<ul class="">
<li><code><a title="diem.testing.miniwallet.client.Payment.account_id" href="#diem.testing.miniwallet.client.Payment.account_id">account_id</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.Payment.amount" href="#diem.testing.miniwallet.client.Payment.amount">amount</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.Payment.currency" href="#diem.testing.miniwallet.client.Payment.currency">currency</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.Payment.id" href="#diem.testing.miniwallet.client.Payment.id">id</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.Payment.payee" href="#diem.testing.miniwallet.client.Payment.payee">payee</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="diem.testing.miniwallet.client.RestClient" href="#diem.testing.miniwallet.client.RestClient">RestClient</a></code></h4>
<ul class="two-column">
<li><code><a title="diem.testing.miniwallet.client.RestClient.create" href="#diem.testing.miniwallet.client.RestClient.create">create</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.create_account" href="#diem.testing.miniwallet.client.RestClient.create_account">create_account</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.get" href="#diem.testing.miniwallet.client.RestClient.get">get</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.kyc_sample" href="#diem.testing.miniwallet.client.RestClient.kyc_sample">kyc_sample</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.logger" href="#diem.testing.miniwallet.client.RestClient.logger">logger</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.name" href="#diem.testing.miniwallet.client.RestClient.name">name</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.new_kyc_data" href="#diem.testing.miniwallet.client.RestClient.new_kyc_data">new_kyc_data</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.send" href="#diem.testing.miniwallet.client.RestClient.send">send</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.server_url" href="#diem.testing.miniwallet.client.RestClient.server_url">server_url</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.session" href="#diem.testing.miniwallet.client.RestClient.session">session</a></code></li>
<li><code><a title="diem.testing.miniwallet.client.RestClient.with_retry" href="#diem.testing.miniwallet.client.RestClient.with_retry">with_retry</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>