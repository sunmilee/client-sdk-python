<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>diem.testing.suites.test_offchain_protocol_error_cases API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>diem.testing.suites.test_offchain_protocol_error_cases</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) The Diem Core Contributors
# SPDX-License-Identifier: Apache-2.0

from dataclasses import asdict
from diem import identifier, jsonrpc, offchain, testnet
from diem.testing import LocalAccount
from diem.testing.miniwallet import RestClient, AppConfig
from typing import Dict, Any, Tuple, Optional
import json, time, requests, uuid, pytest


def test_invalid_x_request_id(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint with X-Request-ID does not
       match UUID format.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
        x_request_id=&#34;invalid uuid&#34;,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_http_header&#34;, &#34;protocol_error&#34;)


def test_missing_x_request_id(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint without X-Request-ID.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `missing_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
        x_request_id=None,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;missing_http_header&#34;, &#34;protocol_error&#34;)


@pytest.mark.parametrize(
    &#34;invalid_sender_address&#34;,
    [
        &#34;invalid hex-encoded address&#34;,
        &#34;18e97a844979a76b030119db95aaf9d0&#34;,
        &#34;xdm1p7ujcndcl7nudzwt8fglhx6wxn08kgs5tm6mz4us2vfufk&#34;,
    ],
)
def test_invalid_x_request_sender_address(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
    invalid_sender_address: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint with invalid X-Request-Sender-Address.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        invalid_sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_http_header&#34;, &#34;protocol_error&#34;)


def test_missing_x_request_sender_address(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint without X-Request-Sender-Address header.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `missing_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        None,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;missing_http_header&#34;, &#34;protocol_error&#34;)


def test_x_request_sender_is_valid_but_no_compliance_key(
    target_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a new on-chain account without base_url and compliance key.
    2. Use new on-chain account address as sender address to create payment command request.
    3. Send request to the target wallet application offchain API endpoint with new on-chain account address.
    4. Expect response status code is 400
    5. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_http_header` error code.
    &#34;&#34;&#34;

    new_stub_account = testnet.gen_account(diem_client)
    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = new_stub_account.account_identifier()
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        new_stub_account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_http_header&#34;, &#34;protocol_error&#34;)


def test_invalid_jws_message_body_that_misses_parts(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a new on-chain account with base_url and compliance key.
    2. Use new on-chain account address as sender address to create payment command request.
    3. Send request that missed jws header part to the target wallet application offchain API endpoint.
    4. Expect response status code is 400
    5. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_jws` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
        request_body=b&#34;invalid.jws_msg&#34;,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_jws&#34;, &#34;protocol_error&#34;)


def test_invalid_jws_message_signature(
    stub_config: AppConfig,
    target_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a new on-chain account with base_url and a new compliance key.
    2. Use new on-chain account address as sender address to create payment command request.
    3. Send request to the target wallet application offchain API endpoint with new on-chain account address and a different compliance key.
    4. Expect response status code is 400
    5. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_jws_signature` error code.
    &#34;&#34;&#34;

    new_stub_account = testnet.gen_account(diem_client)
    new_compliance_key = LocalAccount().compliance_public_key_bytes
    new_stub_account.rotate_dual_attestation_info(diem_client, stub_config.server_url, new_compliance_key)

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = new_stub_account.account_identifier()
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )

    status_code, resp = send_request_json(
        diem_client,
        new_stub_account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_jws_signature&#34;, &#34;protocol_error&#34;)


def send_request_json(
    diem_client: jsonrpc.Client,
    sender_account: LocalAccount,
    sender_address: Optional[str],
    receiver_address: str,
    request_json: str,
    hrp: str,
    x_request_id: Optional[str] = str(uuid.uuid4()),
    request_body: Optional[bytes] = None,
) -&gt; Tuple[int, offchain.CommandResponseObject]:
    headers = {}
    if x_request_id:
        headers[offchain.http_header.X_REQUEST_ID] = x_request_id
    if sender_address:
        headers[offchain.http_header.X_REQUEST_SENDER_ADDRESS] = sender_address

    account_address, _ = identifier.decode_account(receiver_address, hrp)
    base_url, public_key = diem_client.get_base_url_and_compliance_key(account_address)
    if request_body is None:
        request_body = offchain.jws.serialize_string(request_json, sender_account.compliance_key.sign)
    resp = requests.Session().post(
        f&#34;{base_url.rstrip(&#39;/&#39;)}/v2/command&#34;,
        data=request_body,
        headers=headers,
    )

    cmd_resp_obj = offchain.jws.deserialize(resp.content, offchain.CommandResponseObject, public_key.verify)

    return (resp.status_code, cmd_resp_obj)


def payment_command_request_sample(
    sender_address: str, sender_kyc_data: offchain.KycDataObject, receiver_address: str, currency: str, amount: int
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Creates a `PaymentCommand` initial state request JSON object (dictionary).

    Sender address is from the stub wallet application.

    Receiver address is from the target wallet application.
    &#34;&#34;&#34;

    return {
        &#34;_ObjectType&#34;: &#34;CommandRequestObject&#34;,
        &#34;cid&#34;: str(uuid.uuid4()),
        &#34;command_type&#34;: &#34;PaymentCommand&#34;,
        &#34;command&#34;: {
            &#34;_ObjectType&#34;: &#34;PaymentCommand&#34;,
            &#34;payment&#34;: {
                &#34;reference_id&#34;: str(uuid.uuid4()),
                &#34;sender&#34;: {
                    &#34;address&#34;: sender_address,
                    &#34;status&#34;: {&#34;status&#34;: &#34;needs_kyc_data&#34;},
                    &#34;kyc_data&#34;: asdict(sender_kyc_data),
                },
                &#34;receiver&#34;: {
                    &#34;address&#34;: receiver_address,
                    &#34;status&#34;: {&#34;status&#34;: &#34;none&#34;},
                },
                &#34;action&#34;: {
                    &#34;amount&#34;: amount,
                    &#34;currency&#34;: currency,
                    &#34;action&#34;: &#34;charge&#34;,
                    &#34;timestamp&#34;: int(time.time()),
                },
            },
        },
    }


def assert_response_error(
    resp: offchain.CommandResponseObject, code: str, err_type: str, field: Optional[str] = None
) -&gt; None:
    assert resp.error, resp
    assert resp.error.type == err_type, resp
    assert resp.error.code == code, resp
    assert resp.error.field == field, resp</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.assert_response_error"><code class="name flex">
<span>def <span class="ident">assert_response_error</span></span>(<span>resp: <a title="diem.offchain.types.command_types.CommandResponseObject" href="../../offchain/types/command_types.html#diem.offchain.types.command_types.CommandResponseObject">CommandResponseObject</a>, code: str, err_type: str, field: Optional[str] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_response_error(
    resp: offchain.CommandResponseObject, code: str, err_type: str, field: Optional[str] = None
) -&gt; None:
    assert resp.error, resp
    assert resp.error.type == err_type, resp
    assert resp.error.code == code, resp
    assert resp.error.field == field, resp</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.payment_command_request_sample"><code class="name flex">
<span>def <span class="ident">payment_command_request_sample</span></span>(<span>sender_address: str, sender_kyc_data: <a title="diem.offchain.types.payment_types.KycDataObject" href="../../offchain/types/payment_types.html#diem.offchain.types.payment_types.KycDataObject">KycDataObject</a>, receiver_address: str, currency: str, amount: int) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code>PaymentCommand</code> initial state request JSON object (dictionary).</p>
<p>Sender address is from the stub wallet application.</p>
<p>Receiver address is from the target wallet application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def payment_command_request_sample(
    sender_address: str, sender_kyc_data: offchain.KycDataObject, receiver_address: str, currency: str, amount: int
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Creates a `PaymentCommand` initial state request JSON object (dictionary).

    Sender address is from the stub wallet application.

    Receiver address is from the target wallet application.
    &#34;&#34;&#34;

    return {
        &#34;_ObjectType&#34;: &#34;CommandRequestObject&#34;,
        &#34;cid&#34;: str(uuid.uuid4()),
        &#34;command_type&#34;: &#34;PaymentCommand&#34;,
        &#34;command&#34;: {
            &#34;_ObjectType&#34;: &#34;PaymentCommand&#34;,
            &#34;payment&#34;: {
                &#34;reference_id&#34;: str(uuid.uuid4()),
                &#34;sender&#34;: {
                    &#34;address&#34;: sender_address,
                    &#34;status&#34;: {&#34;status&#34;: &#34;needs_kyc_data&#34;},
                    &#34;kyc_data&#34;: asdict(sender_kyc_data),
                },
                &#34;receiver&#34;: {
                    &#34;address&#34;: receiver_address,
                    &#34;status&#34;: {&#34;status&#34;: &#34;none&#34;},
                },
                &#34;action&#34;: {
                    &#34;amount&#34;: amount,
                    &#34;currency&#34;: currency,
                    &#34;action&#34;: &#34;charge&#34;,
                    &#34;timestamp&#34;: int(time.time()),
                },
            },
        },
    }</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.send_request_json"><code class="name flex">
<span>def <span class="ident">send_request_json</span></span>(<span>diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, sender_account: <a title="diem.testing.local_account.LocalAccount" href="../local_account.html#diem.testing.local_account.LocalAccount">LocalAccount</a>, sender_address: Optional[str], receiver_address: str, request_json: str, hrp: str, x_request_id: Optional[str] = 'e92ecbf4-292a-425f-8170-060b92d6134a', request_body: Optional[bytes] = None) ‑> Tuple[int, <a title="diem.offchain.types.command_types.CommandResponseObject" href="../../offchain/types/command_types.html#diem.offchain.types.command_types.CommandResponseObject">CommandResponseObject</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_request_json(
    diem_client: jsonrpc.Client,
    sender_account: LocalAccount,
    sender_address: Optional[str],
    receiver_address: str,
    request_json: str,
    hrp: str,
    x_request_id: Optional[str] = str(uuid.uuid4()),
    request_body: Optional[bytes] = None,
) -&gt; Tuple[int, offchain.CommandResponseObject]:
    headers = {}
    if x_request_id:
        headers[offchain.http_header.X_REQUEST_ID] = x_request_id
    if sender_address:
        headers[offchain.http_header.X_REQUEST_SENDER_ADDRESS] = sender_address

    account_address, _ = identifier.decode_account(receiver_address, hrp)
    base_url, public_key = diem_client.get_base_url_and_compliance_key(account_address)
    if request_body is None:
        request_body = offchain.jws.serialize_string(request_json, sender_account.compliance_key.sign)
    resp = requests.Session().post(
        f&#34;{base_url.rstrip(&#39;/&#39;)}/v2/command&#34;,
        data=request_body,
        headers=headers,
    )

    cmd_resp_obj = offchain.jws.deserialize(resp.content, offchain.CommandResponseObject, public_key.verify)

    return (resp.status_code, cmd_resp_obj)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_jws_message_body_that_misses_parts"><code class="name flex">
<span>def <span class="ident">test_invalid_jws_message_body_that_misses_parts</span></span>(<span>stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, stub_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, currency: str, travel_rule_threshold: int, hrp: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:</p>
<ol>
<li>Create a new on-chain account with base_url and compliance key.</li>
<li>Use new on-chain account address as sender address to create payment command request.</li>
<li>Send request that missed jws header part to the target wallet application offchain API endpoint.</li>
<li>Expect response status code is 400</li>
<li>Expect response <code>CommandResponseObject</code> with failure status, <code>protocol_error</code> error type,
and <code>invalid_jws</code> error code.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_invalid_jws_message_body_that_misses_parts(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a new on-chain account with base_url and compliance key.
    2. Use new on-chain account address as sender address to create payment command request.
    3. Send request that missed jws header part to the target wallet application offchain API endpoint.
    4. Expect response status code is 400
    5. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_jws` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
        request_body=b&#34;invalid.jws_msg&#34;,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_jws&#34;, &#34;protocol_error&#34;)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_jws_message_signature"><code class="name flex">
<span>def <span class="ident">test_invalid_jws_message_signature</span></span>(<span>stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, currency: str, travel_rule_threshold: int, hrp: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:</p>
<ol>
<li>Create a new on-chain account with base_url and a new compliance key.</li>
<li>Use new on-chain account address as sender address to create payment command request.</li>
<li>Send request to the target wallet application offchain API endpoint with new on-chain account address and a different compliance key.</li>
<li>Expect response status code is 400</li>
<li>Expect response <code>CommandResponseObject</code> with failure status, <code>protocol_error</code> error type,
and <code>invalid_jws_signature</code> error code.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_invalid_jws_message_signature(
    stub_config: AppConfig,
    target_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a new on-chain account with base_url and a new compliance key.
    2. Use new on-chain account address as sender address to create payment command request.
    3. Send request to the target wallet application offchain API endpoint with new on-chain account address and a different compliance key.
    4. Expect response status code is 400
    5. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_jws_signature` error code.
    &#34;&#34;&#34;

    new_stub_account = testnet.gen_account(diem_client)
    new_compliance_key = LocalAccount().compliance_public_key_bytes
    new_stub_account.rotate_dual_attestation_info(diem_client, stub_config.server_url, new_compliance_key)

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = new_stub_account.account_identifier()
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )

    status_code, resp = send_request_json(
        diem_client,
        new_stub_account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_jws_signature&#34;, &#34;protocol_error&#34;)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_x_request_id"><code class="name flex">
<span>def <span class="ident">test_invalid_x_request_id</span></span>(<span>stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, stub_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, currency: str, travel_rule_threshold: int, hrp: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:</p>
<ol>
<li>Create a valid offchain request object.</li>
<li>Send request to the target wallet application offchain API endpoint with X-Request-ID does not
match UUID format.</li>
<li>Expect response status code is 400</li>
<li>Expect response <code>CommandResponseObject</code> with failure status, <code>protocol_error</code> error type,
and <code>invalid_http_header</code> error code.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_invalid_x_request_id(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint with X-Request-ID does not
       match UUID format.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
        x_request_id=&#34;invalid uuid&#34;,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_http_header&#34;, &#34;protocol_error&#34;)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_x_request_sender_address"><code class="name flex">
<span>def <span class="ident">test_invalid_x_request_sender_address</span></span>(<span>stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, stub_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, currency: str, travel_rule_threshold: int, hrp: str, invalid_sender_address: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:</p>
<ol>
<li>Create a valid offchain request object.</li>
<li>Send request to the target wallet application offchain API endpoint with invalid X-Request-Sender-Address.</li>
<li>Expect response status code is 400</li>
<li>Expect response <code>CommandResponseObject</code> with failure status, <code>protocol_error</code> error type,
and <code>invalid_http_header</code> error code.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.parametrize(
    &#34;invalid_sender_address&#34;,
    [
        &#34;invalid hex-encoded address&#34;,
        &#34;18e97a844979a76b030119db95aaf9d0&#34;,
        &#34;xdm1p7ujcndcl7nudzwt8fglhx6wxn08kgs5tm6mz4us2vfufk&#34;,
    ],
)
def test_invalid_x_request_sender_address(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
    invalid_sender_address: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint with invalid X-Request-Sender-Address.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        invalid_sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_http_header&#34;, &#34;protocol_error&#34;)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.test_missing_x_request_id"><code class="name flex">
<span>def <span class="ident">test_missing_x_request_id</span></span>(<span>stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, stub_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, currency: str, travel_rule_threshold: int, hrp: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:</p>
<ol>
<li>Create a valid offchain request object.</li>
<li>Send request to the target wallet application offchain API endpoint without X-Request-ID.</li>
<li>Expect response status code is 400</li>
<li>Expect response <code>CommandResponseObject</code> with failure status, <code>protocol_error</code> error type,
and <code>missing_http_header</code> error code.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_x_request_id(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint without X-Request-ID.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `missing_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
        x_request_id=None,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;missing_http_header&#34;, &#34;protocol_error&#34;)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.test_missing_x_request_sender_address"><code class="name flex">
<span>def <span class="ident">test_missing_x_request_sender_address</span></span>(<span>stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, stub_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, currency: str, travel_rule_threshold: int, hrp: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:</p>
<ol>
<li>Create a valid offchain request object.</li>
<li>Send request to the target wallet application offchain API endpoint without X-Request-Sender-Address header.</li>
<li>Expect response status code is 400</li>
<li>Expect response <code>CommandResponseObject</code> with failure status, <code>protocol_error</code> error type,
and <code>missing_http_header</code> error code.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_missing_x_request_sender_address(
    stub_config: AppConfig,
    target_client: RestClient,
    stub_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a valid offchain request object.
    2. Send request to the target wallet application offchain API endpoint without X-Request-Sender-Address header.
    3. Expect response status code is 400
    4. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `missing_http_header` error code.
    &#34;&#34;&#34;

    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = stub_client.create_account().generate_account_identifier(hrp)
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        stub_config.account,
        None,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;missing_http_header&#34;, &#34;protocol_error&#34;)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_offchain_protocol_error_cases.test_x_request_sender_is_valid_but_no_compliance_key"><code class="name flex">
<span>def <span class="ident">test_x_request_sender_is_valid_but_no_compliance_key</span></span>(<span>target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, currency: str, travel_rule_threshold: int, hrp: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:</p>
<ol>
<li>Create a new on-chain account without base_url and compliance key.</li>
<li>Use new on-chain account address as sender address to create payment command request.</li>
<li>Send request to the target wallet application offchain API endpoint with new on-chain account address.</li>
<li>Expect response status code is 400</li>
<li>Expect response <code>CommandResponseObject</code> with failure status, <code>protocol_error</code> error type,
and <code>invalid_http_header</code> error code.</li>
</ol></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_x_request_sender_is_valid_but_no_compliance_key(
    target_client: RestClient,
    diem_client: jsonrpc.Client,
    currency: str,
    travel_rule_threshold: int,
    hrp: str,
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:

    1. Create a new on-chain account without base_url and compliance key.
    2. Use new on-chain account address as sender address to create payment command request.
    3. Send request to the target wallet application offchain API endpoint with new on-chain account address.
    4. Expect response status code is 400
    5. Expect response `CommandResponseObject` with failure status, `protocol_error` error type,
       and `invalid_http_header` error code.
    &#34;&#34;&#34;

    new_stub_account = testnet.gen_account(diem_client)
    receiver_address = target_client.create_account().generate_account_identifier(hrp)
    sender_address = new_stub_account.account_identifier()
    request = payment_command_request_sample(
        sender_address=sender_address,
        sender_kyc_data=target_client.new_kyc_data(sample=&#34;minimum&#34;),
        receiver_address=receiver_address,
        currency=currency,
        amount=travel_rule_threshold,
    )
    status_code, resp = send_request_json(
        diem_client,
        new_stub_account,
        sender_address,
        receiver_address,
        json.dumps(request),
        hrp,
    )
    assert status_code == 400
    assert resp.status == &#34;failure&#34;
    assert_response_error(resp, &#34;invalid_http_header&#34;, &#34;protocol_error&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="diem.testing.suites" href="index.html">diem.testing.suites</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.assert_response_error" href="#diem.testing.suites.test_offchain_protocol_error_cases.assert_response_error">assert_response_error</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.payment_command_request_sample" href="#diem.testing.suites.test_offchain_protocol_error_cases.payment_command_request_sample">payment_command_request_sample</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.send_request_json" href="#diem.testing.suites.test_offchain_protocol_error_cases.send_request_json">send_request_json</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_jws_message_body_that_misses_parts" href="#diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_jws_message_body_that_misses_parts">test_invalid_jws_message_body_that_misses_parts</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_jws_message_signature" href="#diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_jws_message_signature">test_invalid_jws_message_signature</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_x_request_id" href="#diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_x_request_id">test_invalid_x_request_id</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_x_request_sender_address" href="#diem.testing.suites.test_offchain_protocol_error_cases.test_invalid_x_request_sender_address">test_invalid_x_request_sender_address</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.test_missing_x_request_id" href="#diem.testing.suites.test_offchain_protocol_error_cases.test_missing_x_request_id">test_missing_x_request_id</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.test_missing_x_request_sender_address" href="#diem.testing.suites.test_offchain_protocol_error_cases.test_missing_x_request_sender_address">test_missing_x_request_sender_address</a></code></li>
<li><code><a title="diem.testing.suites.test_offchain_protocol_error_cases.test_x_request_sender_is_valid_but_no_compliance_key" href="#diem.testing.suites.test_offchain_protocol_error_cases.test_x_request_sender_is_valid_but_no_compliance_key">test_x_request_sender_is_valid_but_no_compliance_key</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>