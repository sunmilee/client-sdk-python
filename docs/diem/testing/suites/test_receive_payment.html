<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>diem.testing.suites.test_receive_payment API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>diem.testing.suites.test_receive_payment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) The Diem Core Contributors
# SPDX-License-Identifier: Apache-2.0

from diem.testing.miniwallet import RestClient, AccountResource, Transaction, AppConfig, RefundReason
from diem import jsonrpc, stdlib, utils, txnmetadata, diem_types
from typing import Generator, Optional
import pytest


amount: int = 123


@pytest.fixture
def sender_account(
    stub_client: RestClient, currency: str, pending_income_account: AccountResource
) -&gt; Generator[AccountResource, None, None]:
    account = stub_client.create_account(balances={currency: amount})
    yield account
    account.log_events()
    # MiniWallet stub saves the payment without account information (subaddress / reference id)
    # into a pending income account before process it.
    # Here we log events of the account for showing more context related to the test
    # when test failed.
    pending_income_account.log_events()


@pytest.fixture
def receiver_account(target_client: RestClient) -&gt; Generator[AccountResource, None, None]:
    account = target_client.create_account()
    yield account
    account.log_events()


@pytest.mark.parametrize(&#34;invalid_metadata&#34;, [b&#34;&#34;, b&#34;invalid metadata&#34;])
def test_receive_payment_with_invalid_metadata(
    sender_account: AccountResource,
    receiver_account: AccountResource,
    currency: str,
    hrp: str,
    stub_config: AppConfig,
    diem_client: jsonrpc.Client,
    invalid_metadata: bytes,
) -&gt; None:
    &#34;&#34;&#34;When received a payment with invalid metadata, it is up to the wallet application how to handle it.
    This test makes sure target wallet application should continue to process valid transactions after
    received such an on-chain transaction.

    Test Plan:
    1. Generate a valid payment URI from receiver account.
    2. Submit a p2p transaction with invalid metadata, and wait for it is executed.
    3. Send a valid payment to the payment URI.
    4. Assert receiver account received the valid payment.
    &#34;&#34;&#34;

    uri = receiver_account.generate_payment_uri()
    receiver_account_address = uri.intent(hrp).account_address
    stub_config.account.submit_and_wait_for_txn(
        diem_client,
        stdlib.encode_peer_to_peer_with_metadata_script(
            currency=utils.currency_code(currency),
            amount=amount * 2,
            payee=receiver_account_address,
            metadata=invalid_metadata,
            metadata_signature=b&#34;&#34;,
        ),
    )
    assert receiver_account.balance(currency) == 0

    pay = sender_account.send_payment(currency=currency, amount=amount, payee=uri.intent(hrp).account_id)
    wait_for_payment_transaction_complete(sender_account, pay.id)
    receiver_account.wait_for_balance(currency, amount)


def test_receive_payment_with_general_metadata_and_valid_from_and_to_subaddresses(
    sender_account: AccountResource, receiver_account: AccountResource, currency: str, hrp: str
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:
    1. Generate a valid payment URI from receiver account.
    2. Send a payment to the payee from the valid payment URI.
    4. Wait for the transaction executed successfully.
    5. Assert receiver account received the fund.
    &#34;&#34;&#34;
    uri = receiver_account.generate_payment_uri()
    pay = sender_account.send_payment(currency=currency, amount=amount, payee=uri.intent(hrp).account_id)
    wait_for_payment_transaction_complete(sender_account, pay.id)
    receiver_account.wait_for_balance(currency, amount)


@pytest.mark.parametrize(  # pyre-ignore
    &#34;invalid_to_subaddress&#34;, [None, b&#34;&#34;, b&#34;bb4a3ba109a3175f&#34;, b&#34;subaddress_more_than_8_bytes&#34;, b&#34;too_short&#34;]
)
def test_receive_payment_with_general_metadata_and_invalid_to_subaddress(
    sender_account: AccountResource,
    receiver_account: AccountResource,
    currency: str,
    hrp: str,
    stub_config: AppConfig,
    diem_client: jsonrpc.Client,
    invalid_to_subaddress: Optional[bytes],
) -&gt; None:
    &#34;&#34;&#34;When received a payment with general metadata and invalid to subaddress,
    receiver should refund the payment by using RefundMetadata with reason `invalid subaddress`.

    Test Plan:
    1. Generate a valid payment URI from the receiver account.
    2. Create a general metadata with valid from subaddress and invalid to subaddress.
    3. Send payment transaction from sender to receiver on-chain account.
    4. Wait for the transaction executed successfully.
    5. Assert sender account received a payment transaction with refund metadata.
    6. Assert receiver account does not receive funds.
    &#34;&#34;&#34;

    receiver_uri = receiver_account.generate_payment_uri()
    receiver_account_address: diem_types.AccountAddress = receiver_uri.intent(hrp).account_address

    sender_uri = sender_account.generate_payment_uri()
    valid_from_subaddress = sender_uri.intent(hrp).subaddress
    invalid_metadata = txnmetadata.general_metadata(valid_from_subaddress, invalid_to_subaddress)
    original_payment_txn: jsonrpc.Transaction = stub_config.account.submit_and_wait_for_txn(
        diem_client,
        stdlib.encode_peer_to_peer_with_metadata_script(
            currency=utils.currency_code(currency),
            amount=amount,
            payee=receiver_account_address,
            metadata=invalid_metadata,
            metadata_signature=b&#34;&#34;,
        ),
    )

    sender_account.wait_for_event(
        &#34;created_transaction&#34;,
        status=Transaction.Status.completed,
        refund_diem_txn_version=original_payment_txn.version,
        refund_reason=RefundReason.invalid_subaddress,
    )
    assert receiver_account.balance(currency) == 0


def wait_for_payment_transaction_complete(account: AccountResource, payment_id: str) -&gt; None:
    # MiniWallet stub generates `updated_transaction` event when transaction is completed on-chain
    # Payment id is same with Transaction id.
    account.wait_for_event(&#34;updated_transaction&#34;, status=Transaction.Status.completed, id=payment_id)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="diem.testing.suites.test_receive_payment.receiver_account"><code class="name flex">
<span>def <span class="ident">receiver_account</span></span>(<span>target_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>) ‑> Generator[<a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, NoneType, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture
def receiver_account(target_client: RestClient) -&gt; Generator[AccountResource, None, None]:
    account = target_client.create_account()
    yield account
    account.log_events()</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_receive_payment.sender_account"><code class="name flex">
<span>def <span class="ident">sender_account</span></span>(<span>stub_client: <a title="diem.testing.miniwallet.client.RestClient" href="../miniwallet/client.html#diem.testing.miniwallet.client.RestClient">RestClient</a>, currency: str, pending_income_account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>) ‑> Generator[<a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, NoneType, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.fixture
def sender_account(
    stub_client: RestClient, currency: str, pending_income_account: AccountResource
) -&gt; Generator[AccountResource, None, None]:
    account = stub_client.create_account(balances={currency: amount})
    yield account
    account.log_events()
    # MiniWallet stub saves the payment without account information (subaddress / reference id)
    # into a pending income account before process it.
    # Here we log events of the account for showing more context related to the test
    # when test failed.
    pending_income_account.log_events()</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_receive_payment.test_receive_payment_with_general_metadata_and_invalid_to_subaddress"><code class="name flex">
<span>def <span class="ident">test_receive_payment_with_general_metadata_and_invalid_to_subaddress</span></span>(<span>sender_account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, receiver_account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, currency: str, hrp: str, stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, invalid_to_subaddress: Optional[bytes]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>When received a payment with general metadata and invalid to subaddress,
receiver should refund the payment by using RefundMetadata with reason <code>invalid subaddress</code>.</p>
<p>Test Plan:
1. Generate a valid payment URI from the receiver account.
2. Create a general metadata with valid from subaddress and invalid to subaddress.
3. Send payment transaction from sender to receiver on-chain account.
4. Wait for the transaction executed successfully.
5. Assert sender account received a payment transaction with refund metadata.
6. Assert receiver account does not receive funds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.parametrize(  # pyre-ignore
    &#34;invalid_to_subaddress&#34;, [None, b&#34;&#34;, b&#34;bb4a3ba109a3175f&#34;, b&#34;subaddress_more_than_8_bytes&#34;, b&#34;too_short&#34;]
)
def test_receive_payment_with_general_metadata_and_invalid_to_subaddress(
    sender_account: AccountResource,
    receiver_account: AccountResource,
    currency: str,
    hrp: str,
    stub_config: AppConfig,
    diem_client: jsonrpc.Client,
    invalid_to_subaddress: Optional[bytes],
) -&gt; None:
    &#34;&#34;&#34;When received a payment with general metadata and invalid to subaddress,
    receiver should refund the payment by using RefundMetadata with reason `invalid subaddress`.

    Test Plan:
    1. Generate a valid payment URI from the receiver account.
    2. Create a general metadata with valid from subaddress and invalid to subaddress.
    3. Send payment transaction from sender to receiver on-chain account.
    4. Wait for the transaction executed successfully.
    5. Assert sender account received a payment transaction with refund metadata.
    6. Assert receiver account does not receive funds.
    &#34;&#34;&#34;

    receiver_uri = receiver_account.generate_payment_uri()
    receiver_account_address: diem_types.AccountAddress = receiver_uri.intent(hrp).account_address

    sender_uri = sender_account.generate_payment_uri()
    valid_from_subaddress = sender_uri.intent(hrp).subaddress
    invalid_metadata = txnmetadata.general_metadata(valid_from_subaddress, invalid_to_subaddress)
    original_payment_txn: jsonrpc.Transaction = stub_config.account.submit_and_wait_for_txn(
        diem_client,
        stdlib.encode_peer_to_peer_with_metadata_script(
            currency=utils.currency_code(currency),
            amount=amount,
            payee=receiver_account_address,
            metadata=invalid_metadata,
            metadata_signature=b&#34;&#34;,
        ),
    )

    sender_account.wait_for_event(
        &#34;created_transaction&#34;,
        status=Transaction.Status.completed,
        refund_diem_txn_version=original_payment_txn.version,
        refund_reason=RefundReason.invalid_subaddress,
    )
    assert receiver_account.balance(currency) == 0</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_receive_payment.test_receive_payment_with_general_metadata_and_valid_from_and_to_subaddresses"><code class="name flex">
<span>def <span class="ident">test_receive_payment_with_general_metadata_and_valid_from_and_to_subaddresses</span></span>(<span>sender_account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, receiver_account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, currency: str, hrp: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Test Plan:
1. Generate a valid payment URI from receiver account.
2. Send a payment to the payee from the valid payment URI.
4. Wait for the transaction executed successfully.
5. Assert receiver account received the fund.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_receive_payment_with_general_metadata_and_valid_from_and_to_subaddresses(
    sender_account: AccountResource, receiver_account: AccountResource, currency: str, hrp: str
) -&gt; None:
    &#34;&#34;&#34;
    Test Plan:
    1. Generate a valid payment URI from receiver account.
    2. Send a payment to the payee from the valid payment URI.
    4. Wait for the transaction executed successfully.
    5. Assert receiver account received the fund.
    &#34;&#34;&#34;
    uri = receiver_account.generate_payment_uri()
    pay = sender_account.send_payment(currency=currency, amount=amount, payee=uri.intent(hrp).account_id)
    wait_for_payment_transaction_complete(sender_account, pay.id)
    receiver_account.wait_for_balance(currency, amount)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_receive_payment.test_receive_payment_with_invalid_metadata"><code class="name flex">
<span>def <span class="ident">test_receive_payment_with_invalid_metadata</span></span>(<span>sender_account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, receiver_account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, currency: str, hrp: str, stub_config: <a title="diem.testing.miniwallet.config.AppConfig" href="../miniwallet/config.html#diem.testing.miniwallet.config.AppConfig">AppConfig</a>, diem_client: <a title="diem.jsonrpc.client.Client" href="../../jsonrpc/client.html#diem.jsonrpc.client.Client">Client</a>, invalid_metadata: bytes) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>When received a payment with invalid metadata, it is up to the wallet application how to handle it.
This test makes sure target wallet application should continue to process valid transactions after
received such an on-chain transaction.</p>
<p>Test Plan:
1. Generate a valid payment URI from receiver account.
2. Submit a p2p transaction with invalid metadata, and wait for it is executed.
3. Send a valid payment to the payment URI.
4. Assert receiver account received the valid payment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pytest.mark.parametrize(&#34;invalid_metadata&#34;, [b&#34;&#34;, b&#34;invalid metadata&#34;])
def test_receive_payment_with_invalid_metadata(
    sender_account: AccountResource,
    receiver_account: AccountResource,
    currency: str,
    hrp: str,
    stub_config: AppConfig,
    diem_client: jsonrpc.Client,
    invalid_metadata: bytes,
) -&gt; None:
    &#34;&#34;&#34;When received a payment with invalid metadata, it is up to the wallet application how to handle it.
    This test makes sure target wallet application should continue to process valid transactions after
    received such an on-chain transaction.

    Test Plan:
    1. Generate a valid payment URI from receiver account.
    2. Submit a p2p transaction with invalid metadata, and wait for it is executed.
    3. Send a valid payment to the payment URI.
    4. Assert receiver account received the valid payment.
    &#34;&#34;&#34;

    uri = receiver_account.generate_payment_uri()
    receiver_account_address = uri.intent(hrp).account_address
    stub_config.account.submit_and_wait_for_txn(
        diem_client,
        stdlib.encode_peer_to_peer_with_metadata_script(
            currency=utils.currency_code(currency),
            amount=amount * 2,
            payee=receiver_account_address,
            metadata=invalid_metadata,
            metadata_signature=b&#34;&#34;,
        ),
    )
    assert receiver_account.balance(currency) == 0

    pay = sender_account.send_payment(currency=currency, amount=amount, payee=uri.intent(hrp).account_id)
    wait_for_payment_transaction_complete(sender_account, pay.id)
    receiver_account.wait_for_balance(currency, amount)</code></pre>
</details>
</dd>
<dt id="diem.testing.suites.test_receive_payment.wait_for_payment_transaction_complete"><code class="name flex">
<span>def <span class="ident">wait_for_payment_transaction_complete</span></span>(<span>account: <a title="diem.testing.miniwallet.client.AccountResource" href="../miniwallet/client.html#diem.testing.miniwallet.client.AccountResource">AccountResource</a>, payment_id: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_payment_transaction_complete(account: AccountResource, payment_id: str) -&gt; None:
    # MiniWallet stub generates `updated_transaction` event when transaction is completed on-chain
    # Payment id is same with Transaction id.
    account.wait_for_event(&#34;updated_transaction&#34;, status=Transaction.Status.completed, id=payment_id)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="diem.testing.suites" href="index.html">diem.testing.suites</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="diem.testing.suites.test_receive_payment.receiver_account" href="#diem.testing.suites.test_receive_payment.receiver_account">receiver_account</a></code></li>
<li><code><a title="diem.testing.suites.test_receive_payment.sender_account" href="#diem.testing.suites.test_receive_payment.sender_account">sender_account</a></code></li>
<li><code><a title="diem.testing.suites.test_receive_payment.test_receive_payment_with_general_metadata_and_invalid_to_subaddress" href="#diem.testing.suites.test_receive_payment.test_receive_payment_with_general_metadata_and_invalid_to_subaddress">test_receive_payment_with_general_metadata_and_invalid_to_subaddress</a></code></li>
<li><code><a title="diem.testing.suites.test_receive_payment.test_receive_payment_with_general_metadata_and_valid_from_and_to_subaddresses" href="#diem.testing.suites.test_receive_payment.test_receive_payment_with_general_metadata_and_valid_from_and_to_subaddresses">test_receive_payment_with_general_metadata_and_valid_from_and_to_subaddresses</a></code></li>
<li><code><a title="diem.testing.suites.test_receive_payment.test_receive_payment_with_invalid_metadata" href="#diem.testing.suites.test_receive_payment.test_receive_payment_with_invalid_metadata">test_receive_payment_with_invalid_metadata</a></code></li>
<li><code><a title="diem.testing.suites.test_receive_payment.wait_for_payment_transaction_complete" href="#diem.testing.suites.test_receive_payment.wait_for_payment_transaction_complete">wait_for_payment_transaction_complete</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>